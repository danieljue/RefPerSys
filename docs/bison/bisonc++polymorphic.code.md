# BisonC++ Polymorphic Implementation Code (`bisonc++polymorphic.code`)

## Overview

The `bisonc++polymorphic.code` file provides the implementation code for the polymorphic semantic value system. It contains the concrete implementations of the virtual methods declared in the polymorphic header, along with utility functions for managing polymorphic values.

## File Structure

### External Declarations
```cpp
#pragma message "RefPerSys bisonc++ bisonc++polymorphic.code"

$insert idoftag  // Generated tag-to-ID mappings

size_t const *s_nErrors_;  // Error counter pointer
```

### Implementation Code
```cpp
Base::~Base()  // Virtual destructor implementation
{}

}  // namespace Meta_
```

## Base Class Implementation

### Virtual Destructor
```cpp
Base::~Base()
{}
```

**Purpose**: Provides virtual destructor for proper cleanup of polymorphic objects.

**Implementation Notes**:
- Empty body - derived classes handle their own cleanup
- Virtual to ensure proper destruction through base pointers
- Required for `std::unique_ptr<Base>` usage in SType

## Tag-to-ID Mapping System

### Generated Mappings
```cpp
$insert idoftag  // Generated by BisonC++

// Example generated code:
size_t idOf(Tag_ tag) {
    switch (tag) {
        case Tag_::INT: return 0;
        case Tag_::STRING: return 1;
        case Tag_::VECTOR: return 2;
        // ... more mappings
        default: return static_cast<size_t>(-1);
    }
}
```

**Purpose**: Provides runtime mapping from type tags to numeric IDs for debugging and serialization.

## Error Counter Integration

### Global Error Tracking
```cpp
size_t const *s_nErrors_;  // Pointer to parser error counter
```

**Purpose**: Allows polymorphic operations to access parser error state.

**Usage**: Can be used for error reporting and recovery in polymorphic operations.

## Integration with Parser Generation

### Template Instantiation Points
The file serves as the implementation companion to the polymorphic header template. It provides:

1. **Virtual Method Implementations**: Concrete implementations of pure virtual methods
2. **Runtime Support**: Functions needed for polymorphic value operations
3. **Debug Integration**: Error counting and diagnostic support

### Generated Code Structure
```cpp
// From bisonc++polymorphic (header template)
namespace Meta_ {
    class Base { /* ... */ };
    template <Tag_ tg_> class Semantic : public Base { /* ... */ };
    class SType { /* ... */ };
}

// From bisonc++polymorphic.code (implementation)
namespace Meta_ {
    Base::~Base() {}  // Implementation

    // Generated tag mappings
    size_t idOf(Tag_ tag) { /* ... */ }

    extern size_t const *s_nErrors_;  // Error counter
}
```

## Memory Management Implementation

### Object Lifecycle
```cpp
// Construction (in header)
template <Tag_ tg_>
Semantic<tg_>::Semantic(Params &&...params)
    : d_data(std::forward<Params>(params)...) {
    d_baseTag = tg_;
}

// Destruction (in this file)
Base::~Base() {
    // Virtual destructor ensures proper cleanup
}
```

### Clone Operations
```cpp
// Implementation in header template
template <Tag_ tg_>
Base *Semantic<tg_>::vClone() const {
    return new Semantic<tg_>{*this};  // Deep copy
}
```

**Memory Safety**:
- **Deep Copying**: Ensures stack operations don't share data
- **Exception Safety**: Copy constructors provide strong exception guarantee
- **Leak Prevention**: Virtual destructor chain ensures cleanup

## Runtime Type System

### Tag Validation
```cpp
// Generated validation functions
bool isValidTag(Tag_ tag) {
    return idOf(tag) != static_cast<size_t>(-1);
}
```

### Type Information Queries
```cpp
// Access to type information at runtime
const char* nameOf(Tag_ tag) {
    switch (tag) {
        case Tag_::INT: return "int";
        case Tag_::STRING: return "std::string";
        // ... more names
    }
}
```

## Error Handling Integration

### Parser Error Access
```cpp
// Access to parser error state
size_t currentErrorCount() {
    return s_nErrors_ ? *s_nErrors_ : 0;
}
```

**Usage in Polymorphic Operations**:
```cpp
// Can check error state during operations
if (currentErrorCount() > maxErrors) {
    // Abort polymorphic operations
    throw ParserError("Too many errors");
}
```

## Performance Considerations

### Memory Overhead
- **Minimal Runtime Cost**: Only virtual destructor call
- **No Per-Object Overhead**: Beyond what's in the header
- **Efficient Cleanup**: Direct destruction without indirection

### Compilation Impact
- **Template Instantiation**: Only used templates are instantiated
- **Code Bloat**: Minimal - just the virtual destructor
- **Link Time**: Fast linking due to small implementation

## Usage in Generated Parsers

### Integration Pattern
```cpp
// Generated parser includes both files
#include "parser.h"        // Contains polymorphic declarations
#include "parser.code"     // Contains this implementation

// Parser can now use polymorphic semantic values
void Parser::reduce_expression() {
    SType result;
    result.assign<Tag_::INT>(
        vs_(0).get<Tag_::INT>() + vs_(1).get<Tag_::INT>()
    );
    // Base::~Base() called during stack operations
}
```

### Exception Safety
```cpp
try {
    SType value;
    value.assign<Tag_::COMPLEX_TYPE>(complex_constructor());
    // Operations...
} catch (...) {
    // Base::~Base() ensures cleanup even on exceptions
}
```

## Debugging Support

### Type Information
```cpp
// Runtime type name lookup
std::string typeName(Tag_ tag) {
    return std::string(nameOf(tag));
}

// Object inspection
void inspectSType(SType const &value) {
    std::cout << "Type: " << typeName(value.tag())
              << ", Address: " << value.data() << std::endl;
}
```

## Comparison with Non-Polymorphic Systems

### Advantages
- **Complete Implementation**: Provides all virtual method implementations
- **Memory Safety**: Ensures proper destruction of complex types
- **Error Integration**: Connects with parser error handling
- **Debug Support**: Runtime type information for debugging

### Minimal Overhead
- **Size**: Very small implementation file
- **Performance**: Only virtual destructor cost
- **Complexity**: Simple, focused implementation

## Maintenance Notes

### Template Coordination
This file must be kept in sync with `bisonc++polymorphic`:
- Virtual method declarations → implementations
- New features in header → corresponding code here
- Type system changes → update implementations

### Version Compatibility
- Changes to Base class → update destructor
- New virtual methods → add implementations
- Error handling changes → update s_nErrors_ usage

This implementation file completes the polymorphic semantic value system by providing the concrete implementations needed for runtime operation, ensuring memory safety and proper integration with the BisonC++ parser generation system.