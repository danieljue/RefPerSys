# BisonC++ Debug Declarations Template (`debugdecl.in`)

## Overview

The `debugdecl.in` file provides the debug facility declarations for BisonC++ parsers. It defines the static variables and function declarations needed for comprehensive parser debugging and tracing.

## File Structure

### Static Debug Output Stream
```cpp
#pragma message "RefPerSys bisonc++ debugdecl.in"

static std::ostringstream s_out_;  // Static output stream for debug messages
```

**Purpose**: Provides a static string stream for accumulating debug output before flushing to console.

### Debug Function Declarations
```cpp
std::string symbol_(int value) const;  // Convert token codes to names

std::string stype_(char const *pre, STYPE_ const &semVal,
                   char const *post = "") const;  // Format semantic values

static std::ostream &dflush_(std::ostream &out);  // Flush debug output
```

## Debug Output Stream Management

### Static Stream Usage
```cpp
// Accumulate debug messages
s_out_ << "Debug message: " << someValue << std::endl;

// Flush to console when needed
dflush_(std::cout);  // Outputs accumulated messages
```

**Benefits**:
- **Buffering**: Reduces I/O overhead by batching output
- **Thread Safety**: Static stream can be used across parser operations
- **Performance**: Defers actual output until needed

### Flush Function Implementation
The `dflush_` function is implemented in `debugfunctions1.in` and handles the actual output to console with proper formatting.

## Symbol Name Resolution

### Token to String Conversion
```cpp
std::string symbol_(int value) const
```

**Purpose**: Converts numeric token codes to human-readable names.

**Implementation** (in `debugfunctions2.in`):
```cpp
std::string symbol_(int value) const {
    auto it = s_symbol.find(value);  // s_symbol is generated token map
    if (it != s_symbol.end())
        return "'" + it->second + "'";
    else if (isprint(value))
        return "`" + std::string(1, (char)value) + "'";
    else
        return "'\\x" + hex_format(value) + "'";
}
```

**Examples**:
- `symbol_(258)` → `"'IDENTIFIER'"` (if 258 maps to IDENTIFIER)
- `symbol_(65)` → `"`A"` (printable character)
- `symbol_(1)` → `"'\\x1'"` (non-printable)

## Semantic Value Formatting

### Type-Safe Value Display
```cpp
std::string stype_(char const *pre, STYPE_ const &semVal,
                   char const *post = "") const
```

**Purpose**: Formats semantic values for debug output with type safety.

**Implementation Options**:
```cpp
// For union-based semantic values
std::string stype_(char const *pre, STYPE_ const &semVal,
                   char const *post) const {
    std::ostringstream ostr;
    ostr << pre << semVal << post;  // Direct output
    return ostr.str();
}

// For polymorphic semantic values (from debugfunctions1.in)
@insert-stype
    std::ostringstream ostr;
    ostr << pre << semVal << post;  // Type-aware output
    return ostr.str();
@end
```

**Usage Examples**:
```cpp
// Debug semantic value on stack
std::cout << stype_("Semantic value: ", vs_(0)) << std::endl;

// Debug current token value
std::cout << stype_("Token value: ", d_val_) << std::endl;
```

## Integration with Parser Base Class

### Declaration in Base Class
```cpp
// In bisonc++base.h
$insert debugdecl  // Inserts these declarations

// Results in:
class @Base {
    // ... other members ...

private:
    static std::ostringstream s_out_;
    std::string symbol_(int value) const;
    std::string stype_(char const *pre, STYPE_ const &semVal,
                       char const *post = "") const;
    static std::ostream &dflush_(std::ostream &out);
};
```

### Access Control
- **`symbol_()`**: `private` - internal debug utility
- **`stype_()`**: `private` - internal debug utility
- **`s_out_`**: `private static` - shared debug buffer
- **`dflush_()`**: `private static` - internal flush utility

## Debug Output Control

### Conditional Compilation
```cpp
// Debug code is only active when debug is enabled
if (d_debug_) {
    s_out_ << "Debug: " << symbol_(token_()) << std::endl;
    dflush_(std::cout);
}
```

### Performance Impact
- **Zero Cost When Disabled**: Debug code paths are conditional
- **Minimal Cost When Enabled**: String operations and output
- **Buffered Output**: Reduces I/O system call frequency

## Generated Token Map

### Symbol Table Integration
```cpp
// Generated by BisonC++ from grammar
static std::unordered_map<int, std::string> s_symbol = {
    {257, "IDENTIFIER"},
    {258, "NUMBER"},
    {259, "STRING"},
    // ... more token mappings
};
```

**Purpose**: Provides reverse mapping from token codes to token names for meaningful debug output.

## Usage in Debug Output

### State Transition Debugging
```cpp
// In parser operations
if (d_debug_) {
    s_out_ << "State " << state_() << ": "
           << symbol_(token_()) << " -> shift to state " << newState
           << stype_(" (value: ", d_val_, ")") << std::endl;
    dflush_(std::cout);
}
```

### Reduction Debugging
```cpp
// During rule reductions
if (d_debug_) {
    s_out_ << "Reducing by rule " << ruleNr
           << stype_(" with result: ", vs_(0)) << std::endl;
    dflush_(std::cout);
}
```

## Error Recovery Debugging

### Recovery State Logging
```cpp
// During error recovery
if (d_debug_) {
    s_out_ << "Error recovery: popping to state " << state_()
           << ", inserting error token" << std::endl;
    dflush_(std::cout);
}
```

## Semantic Action Debugging

### Action Entry/Exit Logging
```cpp
// At action boundaries
if (d_debug_) {
    s_out_ << "Executing action for rule " << ruleNr << std::endl;
    // Action code here
    s_out_ << "Action completed" << stype_(" result: ", vs_(0)) << std::endl;
    dflush_(std::cout);
}
```

## Memory and Performance Considerations

### Static Stream Lifetime
- **Initialization**: Static initialization before main()
- **Lifetime**: Exists for entire program execution
- **Thread Safety**: Single static stream (may need mutex in MT parsers)

### Output Buffering Strategy
- **Accumulate**: Build complete debug messages in memory
- **Batch Output**: Single flush operation per debug point
- **Line Buffering**: Natural line breaks in debug output

### Memory Usage
- **Stream Buffer**: Grows as needed, reused across operations
- **String Operations**: Temporary strings for formatting
- **Token Map**: Static constant data, no runtime allocation

## Customization Points

### Semantic Value Formatting
Users can customize `stype_()` implementation for complex semantic types:

```cpp
// Custom semantic value formatter
std::string MyParserBase::stype_(char const *pre, STYPE_ const &semVal,
                                 char const *post) const {
    std::ostringstream ostr;
    ostr << pre;
    // Custom formatting based on semantic value type
    if (semVal.is_int()) {
        ostr << "INT:" << semVal.as_int();
    } else if (semVal.is_string()) {
        ostr << "STR:'" << semVal.as_string() << "'";
    } else {
        ostr << "UNKNOWN";
    }
    ostr << post;
    return ostr.str();
}
```

### Output Redirection
The `dflush_` function can be modified to redirect debug output:

```cpp
// Redirect to file
std::ostream &MyParserBase::dflush_(std::ostream &out) {
    static std::ofstream debugFile("parser_debug.log", std::ios::app);
    debugFile << s_out_.str() << std::flush;
    s_out_.clear();
    s_out_.str("");
    return out;  // Return original stream
}
```

This debug declarations template provides the foundation for comprehensive parser debugging, enabling developers to trace parsing operations, semantic value flow, and error recovery processes with detailed, human-readable output.