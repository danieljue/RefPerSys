# BisonC++ Debug Functions Implementation 2 (`debugfunctions2.in`)

## Overview

The `debugfunctions2.in` file provides the `symbol_` function implementation for BisonC++ parsers. This function converts numeric token codes to human-readable token names, enabling meaningful debug output during parsing.

## File Structure

### Symbol Resolution Implementation
```cpp
#pragma message "RefPerSys bisonc++ debugfunctions2.in"

std::string @Base::symbol_(int value) const {
    using namespace std;
    ostringstream ostr;
    SMap::const_iterator it = s_symbol.find(value);
    if (it != s_symbol.end())
        ostr << '\'' << it->second << '\'';
    else if (isprint(value))
        ostr << '`' << static_cast<char>(value) << "'";
    else
        ostr << "'\\x" << setfill('0') << hex << setw(2) << value << '\'';
    return ostr.str();
}
```

## Token Name Resolution

### Symbol Map Lookup
```cpp
SMap::const_iterator it = s_symbol.find(value);
if (it != s_symbol.end())
    ostr << '\'' << it->second << '\'';
```

**Generated Symbol Map**: `s_symbol` is generated by BisonC++ from the grammar file, mapping token codes to token names.

**Example Generated Map**:
```cpp
static std::unordered_map<int, std::string> s_symbol = {
    {257, "IDENTIFIER"},
    {258, "NUMBER"}, 
    {259, "STRING_LITERAL"},
    {260, "+"},
    {261, "*"},
    // ... more token mappings
};
```

### Printable Character Handling
```cpp
else if (isprint(value))
    ostr << '`' << static_cast<char>(value) << "'";
```

**Purpose**: For ASCII tokens (operators, punctuation), shows the actual character.

**Examples**:
- `symbol_(43)` → `` `+' `` (for '+' token)
- `symbol_(40)` → `` `(' `` (for '(' token)

### Non-Printable Character Handling
```cpp
else
    ostr << "'\\x" << setfill('0') << hex << setw(2) << value << '\'';
```

**Purpose**: For control characters and non-ASCII values, shows hexadecimal representation.

**Examples**:
- `symbol_(1)` → `'\x01'` (SOH character)
- `symbol_(255)` → `'\xff'` (extended ASCII)

## Output Format Standards

### Token Name Format
- **Named Tokens**: Single quotes around name - `'IDENTIFIER'`
- **Operators**: Backticks around character - `` `+' ``
- **Control Chars**: Hex escape sequence - `'\x01'`

### Consistency with Debug Output
```cpp
// Consistent formatting across debug functions
std::cout << "Token: " << symbol_(token_()) << std::endl;
std::cout << "Expected: " << symbol_(expected_token) << std::endl;
```

## Integration with Parser Operations

### Token Consumption Debugging
```cpp
// In token processing
if (d_debug_) {
    s_out_ << "Consuming token: " << symbol_(token_())
           << " (code: " << token_() << ")" << std::endl;
    dflush_(s_out_);
}
```

### Error Reporting
```cpp
// In error messages
std::cerr << "Syntax error: unexpected " << symbol_(token_())
          << " in state " << state_() << std::endl;
```

### State Transition Logging
```cpp
// In parser state changes
if (d_debug_) {
    s_out_ << "State " << old_state << ": " << symbol_(token_())
           << " -> shift to state " << new_state << std::endl;
    dflush_(s_out_);
}
```

## Generated Symbol Map Details

### Token Code Assignment
BisonC++ assigns token codes starting from 257 (256 is reserved for error token):

```cpp
// Typical token code assignments
#define IDENTIFIER 257
#define NUMBER 258
#define STRING_LITERAL 259
#define PLUS 260
#define MINUS 261
// ... etc
```

### Symbol Map Generation
```cpp
// Generated by BisonC++
static std::unordered_map<int, std::string> s_symbol = {
    {257, "IDENTIFIER"},
    {258, "NUMBER"},
    {259, "STRING_LITERAL"},
    {260, "+"},
    {261, "-"},
    {262, "*"},
    {263, "/"},
    // ... all terminal symbols
};
```

## Error Token Handling

### Special Error Token
```cpp
// Error token (ASCII 256) is predefined
{256, "error"}  // Usually included in symbol map
```

**Purpose**: Used during error recovery to represent syntax errors.

## Performance Considerations

### Lookup Efficiency
- **Hash Table**: `std::unordered_map` provides O(1) average lookup
- **Static Data**: Symbol map is constant, initialized at startup
- **No Dynamic Allocation**: During parsing operations

### Memory Usage
- **Static Map**: Fixed size based on grammar terminals
- **String Storage**: Token names stored once, referenced by pointers
- **No Per-Lookup Cost**: Reuses existing string objects

## Customization Options

### Custom Symbol Names
Users can modify the generated symbol map for custom token names:

```cpp
// In generated parser code
static std::unordered_map<int, std::string> s_symbol = {
    {257, "MY_IDENTIFIER"},  // Custom name
    {258, "MY_NUMBER"},      // Custom name
    // ... standard mappings
};
```

### Extended Symbol Resolution
For complex grammars, users can override `symbol_()`:

```cpp
std::string MyParserBase::symbol_(int value) const {
    // Custom token name resolution
    switch (value) {
        case MY_SPECIAL_TOKEN: return "'MY_SPECIAL'";
        case ANOTHER_TOKEN: return "'ANOTHER'";
        default: return Base::symbol_(value);  // Fallback to default
    }
}
```

## Internationalization Support

### Unicode Token Names
For grammars with Unicode operators or keywords:

```cpp
static std::unordered_map<int, std::string> s_symbol = {
    {257, "идентификатор"},    // Cyrillic "identifier"
    {258, "число"},           // Cyrillic "number"
    {259, "∑"},              // Greek sigma
    // ... Unicode token names
};
```

### Character Encoding
The `isprint()` function uses current locale for character classification, supporting different character encodings.

## Debugging Complex Grammars

### Token Alias Support
For grammars with multiple names for the same token:

```cpp
// Multiple representations
{260, "+ (PLUS)"},      // Shows both symbol and name
{261, "- (MINUS)"},     // Shows both symbol and name
```

### Contextual Token Names
For context-sensitive tokens:

```cpp
std::string MyParserBase::symbol_(int value) const {
    // Context-aware token naming
    if (in_expression_context) {
        switch (value) {
            case 260: return "'+' (addition)";
            case 261: return "'-' (subtraction)";
        }
    }
    return Base::symbol_(value);
}
```

## Error Recovery Integration

### Error Token Display
```cpp
// During error recovery
if (d_debug_) {
    s_out_ << "Inserting error token: " << symbol_(errTok_)
           << " in state " << state_() << std::endl;
    dflush_(s_out_);
}
```

### Unexpected Token Reporting
```cpp
// Syntax error details
std::cerr << "Unexpected token " << symbol_(token_())
          << " (expected one of: ";
for (auto expected : expected_tokens) {
    std::cerr << symbol_(expected) << " ";
}
std::cerr << ")" << std::endl;
```

## Thread Safety

### Static Data Access
- **Read-Only**: Symbol map is never modified after initialization
- **Thread-Safe**: Can be safely accessed from multiple threads
- **No Synchronization Needed**: For read operations

### String Stream Usage
- **Local Strings**: `symbol_()` returns new string each call
- **No Shared State**: Each call is independent
- **Exception Safe**: No side effects on failure

This symbol resolution implementation provides clear, human-readable token identification for parser debugging, supporting both simple ASCII tokens and complex Unicode grammars with efficient lookup and flexible customization options.